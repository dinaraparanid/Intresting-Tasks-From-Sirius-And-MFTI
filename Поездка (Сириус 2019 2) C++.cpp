/*В 2029 году три финала Всероссийской олимпиады — по химии, информатике и физкультуре — проводятся в Самаре. Из Саратова прошло много участников по каждому из этих предметов, и все они планируют ехать в Самару на поезде. Руководитель сборной по химии уже купил билеты для своих подопечных. Руководитель сборной по информатике как раз сейчас планирует этим заняться. Но программисты — странные люди, у которых есть много запросов к купленным местам. Например, они категорически не хотят ехать в одном вагоне со спортсменами (участниками сборной по физкультуре), а также со всеми другими людьми, не прошедшими на всерос (то есть, из всех возможных людей, они готовы терпеть только всероссников по химии).

К счастью, пока кроме химиков ещё никто не успел купить билеты на поезд, так что всё, что нужно обеспечить руководителю, это чтобы после покупки билетов, в вагонах, в которых поедут участники сборной по информатике не осталось свободных мест (тогда там точно не поедут посторонние).

Но у руководителя есть и свои ограничения — он хочет, чтобы вагонов, в которых поедут его подопечные, было как можно меньше и они шли подряд (при этом допускается, чтобы между ними были целиком занятые вагоны).

Помогите руководителю сборной выбрать, в каких вагонах информатики поедут на олимпиаду, или определите, что это невозможно.

Входные данные
В первой строке дано два целых числа n и k (1≤n≤105,1≤k≤109) — число вагонов и участников сборной соответственно.

Во второй строке даны n целых чисел ai (0≤ai≤109) — количество свободных мест в вагонах.

Гарантируется, что суммарное число свободных мест в поезде не превосходит 109.

Выходные данные
Выведите два целых числа — номера первого и последнего вагона, в которых поедут участники сборной.

Если же купить билеты, соблюдая все требования, невозможно, выведите -1.*/

#include <iostream>
#include <queue>
 
int main()
{
	int n, k;
	std::cin >> n >> k;
	
	int* pn = new int[n];
	
	for (int i = 0; i < n; i++)
		std::cin >> pn[i];
	
	int sum = 0, ptr = 0, best_s, best_f, best_l = n + 1;
	
	std::queue<int> que;
	
	while (ptr < n)
	{
		if (sum < k)
		{
			sum += pn[ptr];
			que.push(ptr++);
		}
		else if (sum > k)
		{
			sum -= pn[que.front()];
			que.pop();
		}
		else
		{
			if (que.back() - que.front() < best_l)
			{
				best_l = que.back() - que.front();
				best_s = que.front();
				best_f = que.back();
			}
			sum -= pn[que.front()];
			que.pop();
		}
		
	}
	
	if (sum > k)
	{
		while (sum > k)
		{
			sum -= pn[que.front()];
			que.pop();
		}
	}
	
	if (sum == k )
	{
		if (que.back() - que.front() < best_l)
		{
			best_l = que.back() - que.front();
			best_s = que.front();
			best_f = que.back();
		}
	}
	
	best_l != n + 1 ? std::cout << best_s + 1 << " " << best_f + 1 : std::cout << -1;
	
	delete[] pn;
	return 0;
}