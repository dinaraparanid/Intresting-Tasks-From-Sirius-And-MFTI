/*
В этой задаче Вася готовится к олимпиаде. Учитель дал ему N (1 ≤ N ≤ 100) задач для тренировки. Для каждой из этих задач известно, каким умением ai нужно обладать для её решения. Это означает, что если текущее умение Васи больше либо равно заданного умения для задачи, то он может ее решить. Кроме того, после решения i-й задачи Васино умение увеличивается на число bi.

Исходное умение Васи равно A. Решать данные учителем задачи он может в произвольном порядке. Какое максимальное количество задач он сможет решить, если выберет самый лучший порядок их решения?

Входные данные
Сначала вводятся два целых числа N, A (1 ≤ N ≤ 100, 0 ≤ A ≤ 100) — количество задач и исходное умение. Далее идут N пар целых чисел ai, bi (1 ≤ ai ≤ 100, 1 ≤ bi ≤ 100) — соответственно сколько умения нужно для решения i-й задачи и сколько умения прибавится после её решения.

Выходные данные
Выведите одно число — максимальное количество задач, которое Вася может решить.

Примечание
В первом тесте Вася сможет решить все задачи, выбрав, например, порядок 2, 1, 3. Во втором тесте ему необходимо сначала разобраться с 1 и 3 задачами, после чего он осилит 2.

Примеры
входные данные
3 2
3 1
2 1
1 1
выходные данные
3

входные данные
4 1
1 10
21 5
1 10
100 100
выходные данные
3
*/

#include <cstdio>
#include <set>

class Cmp
{
 public:
	bool operator() (std::pair<int, int> arg1, std::pair<int, int> arg2) const
	{
		if (arg1.second == arg2.second)
			return arg1.first < arg2.first;

		return arg2.second < arg1.second;
	}
};

int main()
{
	int n = 0, a = 0;
	std::scanf("%d%d", &n, &a);

	std::multiset<std::pair<int, int>, Cmp> tasks;

	for (int i = 0; i < n; i++)
	{
		int x = 0, y = 0;
		std::scanf("%d%d", &x, &y);
		tasks.insert(std::make_pair(x, y));
	}

	int cnt = 0, ans = 0;
	auto walk = tasks.begin();

	while (!tasks.empty())
	{
		if (walk->first > a)
			++walk, ++cnt;

		else
		{
			cnt = 0;
			a += walk->second;
			ans++;

			const auto pr = std::next(walk);
			tasks.erase(walk);
			walk = pr;
		}

		if (cnt == tasks.size())
			break;

		if (walk == tasks.end())
			walk = tasks.begin();
	}

	std::printf("%d", ans);

	return 0;
}
