/*Расшифровка
Известно, что если сохранить в каждом слове текста первую и последнюю букву, а остальные переставить произвольным образом, получившийся текст по-прежнему можно достаточно свободно прочитать. В лаборатории информатики исследуют аналогичный феномен для числовых последовательностей.

Будем называть последовательность, состоящую из целых положительных чисел, корректной , если первое число в этой последовательности является минимальным, а последнее — максимальным. Например, последовательности [1, 3, 2, 4] и [1, 2, 1, 2] являются корректными, а последовательность [1, 3, 2] — нет.

Задана последовательность [a1,a2, ...,an] . Будем называть отрезок элементов заданной последовательности [al,al+ 1, ...,ar] корректным, если он представляет собой корректную последовательность: al является минимальным числом на этом отрезке, а ar — максимальным.

В рамках исследования необходимо разбить заданную последовательность на минимальное количество непересекающихся корректных отрезков. Например, последовательность [2, 3, 1, 1, 5, 1] можно разбить на три корректных отрезка: [2, 3] и [1, 1, 5] и [1].

Требуется написать программу, которая по заданной последовательности определяет, на какое минимальное количество корректных отрезков её можно разбить.

Входные данные

Первая строка входных данных содержит целое число n (1 ≤n≤ 300000) — количество элементов в заданной последовательности.

Вторая строка содержит n целых чисел a1,a2, ...,an — заданную последовательность (1 ≤ai≤ 109).

Выходные данные

Выведите одно число — минимальное количество корректных отрезков, на которое можно разбить заданную последовательность.

Примеры
Ввод
Вывод
6
2 3 1 1 5 1

3
--------
5
5 4 3 2 1

5
-------
4
1 3 2 4

1
------
*/

#include <cstdio>
#include <vector>

int main()
{
	int n = 0, groups = 0;
	int max = 0, max_ptr = 0, min = 0;
	std::scanf("%d", &n);
	
	std::vector<int> pn(n);
	std::vector<int> stack(1);
	
	for (int& i : pn)
		std::scanf("%d", &i);
	
	stack[0] = max = min = pn[0];
	int i = 1;
	while (max_ptr != n - 1)
	{
		if (pn[i] < min)
		{
		EMP:
			groups++;
			stack.clear();
			i = max_ptr + 1;
			max = pn[i];
			max_ptr = i;
			min = pn[i];
			stack.push_back(pn[i]);
		}
		else if (pn[i] >= max)
		{
			stack.push_back(pn[i]);
			max = pn[i];
			max_ptr = i;
		}
		else
			stack.push_back(pn[i]);
		
		if (i == n - 1 && max_ptr != n - 1)
			goto EMP;
		i++;
	}
	
	groups++;
	std::printf("%d", groups);
	return 0;
}
